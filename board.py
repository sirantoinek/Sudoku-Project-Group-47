import sys

import pygame

from cell import Cell
import sudoku_generator
import random

from constants import *

"""This class is a WIP. It will be finished by Milestone 3"""


class Board:
    def __init__(self, width, height, screen, difficulty):
        """Create the board with given dimensions, window, and difficulty setting"""

        '''Creates the 2d lists that will store cell info
        original_cells contains the raw ints generated by sudoku_generator
        cells contains the actual Cell instances derived from the ints in original_cells'''
        empty_cells = 30 + 10 * difficulty
        self.original_cells = sudoku_generator.generate_sudoku(9, empty_cells)
        self.cells = []
        for x in range(width):
            column = []
            for y in range(height):
                column.append(Cell(self.original_cells[x][y], y, x, screen))
            self.cells.append(column)

        # save the dimensions for future reference
        self.width = width
        self.height = height

        self.screen = screen

        self.selected_cell = None  # the cell the player has currently selected

    def select(self, row, col):
        """Select a cell at the given row and column"""
        try:
            self.selected_cell = self.cells[col][row]
        except IndexError:
            print(f'There is no cell at ({col}, {row}). There are {self.width} columns and {self.height} rows.')

    def find_empty(self):
        """Returns tuple with row and column of an empty cell"""
        if self.is_full():
            return None

        while True:
            x = random.randint(0, self.width - 1)
            y = random.randint(0, self.height - 1)
            if self.cells[x][y].value == 0:
                return x, y

    def sketch(self, value):
        """Sets sketched value of selected cell"""
        self.selected_cell.set_sketched_value(value)

    def place_number(self, value):
        """Sets value of selected cell"""
        self.selected_cell.set_cell_value(value)

    def clear(self):
        """Clear the selected cell by setting both its value and sketched value back to 0"""
        if self.original_cells[self.selected_cell.row][self.selected_cell.col] != 0:  # this cell was generated by default and can not be changed
            return

        self.selected_cell.set_cell_value(0)
        self.selected_cell.set_sketched_value(0)

    def draw(self):
        """Draw the board"""
        self.screen.fill(BACKGROUND_COLOR)  # draw the background

        '''Draw the grid'''
        '''Create variables specifying the area covered by this board'''
        start_x, end_x = LEFT_MARGIN, self.screen.get_width() - RIGHT_MARGIN
        start_y, end_y = TOP_MARGIN, self.screen.get_height() - BOTTOM_MARGIN
        range_x, range_y = end_x - start_x, end_y - start_y

        '''List of the x and y coordinates that will have lines through them'''
        lines_x = [(i / 9) * range_x + start_x for i in range(0, 10)]
        lines_y = [(i / 9) * range_y + start_y for i in range(0, 10)]
        wide_lines_x, wide_lines_y = lines_x[::3], lines_y[::3]  # these coordinates will have wider lines

        # draw horizontal lines
        for y in lines_y:
            pygame.draw.line(
                self.screen,
                GRID_COLOR,
                (start_x, y),
                (end_x, y),
                10 if y in wide_lines_y else 5
            )

        # draw vertical lines
        for x in lines_x:
            pygame.draw.line(
                self.screen,
                GRID_COLOR,
                (x, start_y),
                (x, end_y),
                10 if x in wide_lines_x else 5
            )

        # draw outline for selected cell
        if self.selected_cell is not None:
            '''Drawing the selected cell will involve drawing 4 red lines
            For convenience, let's store the relevant coordinates'''
            low_x, high_x = lines_x[self.selected_cell.col], lines_x[self.selected_cell.col + 1]
            low_y, high_y = lines_y[self.selected_cell.row], lines_y[self.selected_cell.row + 1]

            '''This list of tuples will store the start and end points of each of the 4 lines'''
            lines = [
                ((low_x, low_y), (high_x, low_y)),  # up
                ((low_x, low_y), (low_x, high_y)),  # left
                ((low_x, high_y), (high_x, high_y)),  # down
                ((high_x, low_y), (high_x, high_y)),  # right
            ]

            '''Loop through all the lines to draw them'''
            for line in lines:
                start, end = line  # unpack the line tuple to get its start and end coordinates
                pygame.draw.line(
                    self.screen,
                    SELECTION_COLOR,
                    start,
                    end,
                    5
                )

        # draw cells
        for x in range(self.width):
            for y in range(self.height):
                self.cells[x][y].draw()
        pygame.display.update()

    def click(self, x, y):
        if x < LEFT_MARGIN or x > self.screen.get_width() - RIGHT_MARGIN or y < TOP_MARGIN or y > self.screen.get_height() - BOTTOM_MARGIN:
            return None
        else:
            return (y - TOP_MARGIN) // CELL_SIZE, (x - LEFT_MARGIN) // CELL_SIZE

    def is_full(self):
        """Check if the board has any empty cells left"""
        for column in self.cells:
            for cell in column:
                if cell.value == 0:  # cell is empty
                    return False
        return True  # no empty cell found

    def reset_to_original(self):
        """Resets all cell values on the board to their originally generated values"""
        for x in range(self.width):
            for y in range(self.height):
                current_cell = self.cells[x][y]
                current_cell.set_cell_value(self.original_cells[x][y])
                current_cell.set_sketched_value(0)

    def check_board(self):
        """Check if the board has been solved"""
        raise NotImplementedError  # FIXME: Nick will implement this function

    def give_cells(self):
        return self.original_cells
        # I don't know how to access self.cells from outside of this file without using this method.


'''Everything below this point is testing code that will only run if board.py is launched directly'''
if __name__ == "__main__":
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption('Sudoku')

    choices = [
        'Select',  # 1
        # 'Find empty',
        'Sketch',  # 2
        'Place number',  # 3
        'clear',  # 4
        'draw',  # 5
        # 'click',
        'Is full',  # 6
        # 'Update board',
        # 'Reset to original',
        # 'Check board'
    ]

    test_board = Board(9, 9, screen, DIFFICULTY_HARD)
    test_board.draw()

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:  # mouse click
                row, col = test_board.click(event.pos[0], event.pos[1])
                print(f'Clicked ({row}, {col})')
                test_board.select(row, col)
                test_board.draw()

        '''for (index, option) in enumerate(choices):
            print(f"{index + 1}. " + option)

        choice = int(input())
        if choice == 1:
            row = int(input("Row:"))
            col = int(input("Col:"))
            test_board.select(row, col)
        elif choice == 2:
            test_board.sketch(int(input("Value:")))
        elif choice == 3:
            test_board.place_number(int(input("Value:")))
        elif choice == 4:
            test_board.clear()
        elif choice == 5:
            test_board.draw()
        elif choice == 6:
            print(test_board.is_full())
        test_board.draw()'''

