from cell import Cell
import sudoku_generator
import random

"""This class is a WIP. It will be finished by Milestone 3"""


class Board:
    def __init__(self, width, height, screen, difficulty):
        """Create the board with given dimensions, window, and difficulty setting"""

        '''Creates the 2d lists that will store cell info
        original_cells contains the raw ints generated by sudoku_generator
        cells contains the actual Cell instances derived from the ints in original_cells'''
        self.original_cells = sudoku_generator.generate_sudoku(9, 30)
        self.cells = []
        for x in range(width):
            column = []
            for y in range(height):
                column.append(Cell(self.original_cells[x][y], x, y, screen))
            self.cells.append(column)

        # save the dimensions for future reference
        self.width = width
        self.height = height

        self.selected_cell = None  # the cell the player has currently selected

    def select(self, row, col):
        """Select a cell at the given row and column"""
        '''the actual indexes are 1 less than the row and column numbers'''
        try:
            self.selected_cell = self.cells[col][row]
        except IndexError:
            print(f'There is no cell at ({col}, {row}). There are {self.width} columns and {self.height} rows.')

    def find_empty(self):
        """Returns tuple with row and column of an empty cell"""
        if self.is_full():
            return None

        while True:
            x = random.randint(0, self.width - 1)
            y = random.randint(0, self.height - 1)
            if self.cells[x][y].value == 0:
                return x, y

    def sketch(self, value):
        """Sets sketched value of selected cell"""
        self.selected_cell.set_sketched_value(value)

    def place_number(self, value):
        """Sets value of selected cell"""
        self.selected_cell.set_cell_value(value)

    def clear(self):
        """Clear the selected cell by setting both its value and sketched value back to 0"""
        if self.original_cells[self.selected_cell.row][self.selected_cell.col] != 0:  # this cell was generated by default and can not be changed
            return

        self.selected_cell.set_cell_value(0)
        self.selected_cell.set_sketched_value(0)

    def draw(self):
        """Draw the board"""
        # FIXME: placeholder behavior
        for y in range(self.height):
            for x in range(self.width):
                print(self.cells[x][y].value, end=' ')
            print()

        '''for x in range(self.width):
            for y in range(self.height):
                self.cells[x][y].draw()'''

    def click(self, x, y):
        """Handle mouse clicks at a point on the board"""
        raise NotImplementedError("GUI not implemented")

    def is_full(self):
        """Check if the board has any empty cells left"""
        for column in self.cells:
            for cell in column:
                if cell.value == 0:  # cell is empty
                    return False
        return True  # no empty cell found

    def reset_to_original(self):
        """Resets all cell values on the board to their originally generated values"""
        for x in range(self.width):
            for y in range(self.height):
                current_cell = self.cells[x][y]
                current_cell.set_cell_value(self.original_cells[x][y])
                current_cell.set_sketched_value(0)

    def check_board(self):
        """Check if the board has been solved"""
        raise NotImplementedError  # FIXME: Nick will implement this function

    def give_cells(self):
        return self.original_cells
        # I don't know how to access self.cells from outside of this file without using this method.


'''Everything below this point is testing code that will only run if board.py is launched directly'''
if __name__ == "__main__":
    choices = [
        'Select',  # 1
        # 'Find empty',
        'Sketch',  # 2
        'Place number',  # 3
        'clear',  # 4
        'draw',  # 5
        # 'click',
        'Is full',  # 6
        # 'Update board',
        # 'Reset to original',
        # 'Check board'
    ]

    test_board = Board(9, 9, None, 0)
    choice = 0
    while choice != -1:
        for (index, option) in enumerate(choices):
            print(f"{index + 1}. " + option)

        choice = int(input())
        if choice == 1:
            row = int(input("Row:"))
            col = int(input("Col:"))
            test_board.select(row, col)
        elif choice == 2:
            test_board.sketch(int(input("Value:")))
        elif choice == 3:
            test_board.place_number(int(input("Value:")))
        elif choice == 4:
            test_board.clear()
        elif choice == 5:
            test_board.draw()
        elif choice == 6:
            print(test_board.is_full())
